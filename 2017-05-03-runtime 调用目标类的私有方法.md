---
layout: post
title: runtime 调用目标类的私有方法
date: 2017-05-03
---


#### 需求  
1. runtime 获取目标类中的私有方法  
2. 调用目标类中的私有方法

#### 实现
  
```
#import <objc/runtime.h>
#import <objc/message.h>

# 方法获取
id LenderClass = objc_getClass("TryViewController");
unsigned int outCount =0;
Method *methods =class_copyMethodList(LenderClass, &outCount);

for(unsigned int i =0; i < outCount; ++i)
{
    Method method = methods[i];
    SEL methodName =method_getName(method);
    NSString *nameString = NSStringFromSelector(methodName);
    
    if ([nameString isEqualToString:@"clickButtonAction:"])
    {
    	# 方法调用
        TryViewController *class = [LenderClass new];
        ((void (*)(id, SEL, UIButton *))(void *)objc_msgSend)(class, sel_registerName("clickButtonAction:"), nil);
        break;
    }
}

```

#### 原理
Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。
当编译器遇到一个方法调用时，它会将方法的调用翻译成以下函数中的一个，
`objc_msgSend`、 `objc_msgSend_stret`、 `objc_msgSendSuper` 和 `objc_msgSendSuper_stret`。

1. 发送给对象的父类的消息会使用 `objc_msgSendSuper` ;
2. 有数据结构作为返回值的方法会使用 `objc_msgSendSuper_stret` 或 `objc_msgSend_stret`;
3. 其它的消息都是使用`objc_msgSend`发送的。


> id objc_msgSend(id self, SEL op, ...)

将消息发送给一个对象并返回一个值，其中 `self` 是消息接收者，`op` 是可变参数

```
id  c_objc_msgSend( struct mulle_nsobject *self, SEL _cmd, ...)
{
   struct mulle_objc_class    *cls; // 类
   struct mulle_objc_cache    *cache; // 缓存列表
   unsigned int               hash;
   struct mulle_objc_method   *method; // 方法列表
   unsigned int               index; // 当前索引值
   
   if( self)
   {
      cls   = self->isa;
      cache = cls->cache;
      hash  = cache->mask;
      index = (unsigned int) _cmd & hash;
      
      do
      {
         method = cache->buckets[ index];
         if( ! method)
            goto recache;
         index = (index + 1) & cache->mask;
      }
      while( method->method_name != _cmd);
      return( (*method->method_imp)( (id) self, _cmd));
   }
   return( (id) self);

recache:
/* ... */
   return( 0);
}
```
参考：

1. [http://oriochan.com/14710029019312.html](http://oriochan.com/14710029019312.html)
2. [http://www.mulle-kybernetik.com/artikel/Optimization/opti-9.html](http://www.mulle-kybernetik.com/artikel/Optimization/opti-9.html)

#### 数据类型
runtime定义了如下的数据类型：
 
```
typedef struct objc_class *Class;
typedef struct objc_object *id;
struct objc_object {
    Class isa;
};
struct objc_class {
    Class isa;
}
 
/// 不透明结构体, selector
typedef struct objc_selector *SEL;
 
/// 函数指针, 用于表示对象方法的实现
typedef id (*IMP)(id, SEL, ...);
```
`id`指代objc中的对象，每个对象的在内存的结构并不是确定的，但其首地址指向的肯定是isa。通过isa指针，运行时就能获取到objc_class。

`objc_class`表示对象的Class，它的结构是确定的，由编译器生成。

`SEL`表示选择器，这是一个不透明结构体。但是实际上，通常可以把它理解为一个字符串。运行时维护着一张SEL的表，将相同字符串的方法名映射到唯一一个SEL。通过sel_registerName(char *name)方法，可以查找到这张表中方法名对应的SEL。苹果提供了一个语法糖@selector用来方便地调用该函数。

`IMP`是一个函数指针。objc中的方法最终会被转换成纯C的函数，IMP就是为了表示这些函数的地址。

参考：[http://blog.ibireme.com/2013/11/26/objective-c-messaging/](http://blog.ibireme.com/2013/11/26/objective-c-messaging/)
