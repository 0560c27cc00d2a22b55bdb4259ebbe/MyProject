##<center> 微信红包实现过程 </centr>

####登录手机
先登录手机，然后执行以下命令  

```
# ps -e | grep WeChat
2577 ??         0:12.88 /var/containers/Bundle/Application/41A87AC1-2BA5-404A-A621-95ED92ED6E14/WeChat.app/WeChat 
# cycript -p WeChat
# UIApp.keyWindow.recursiveDescription().toString()
...
...
# ChatTableViewCell = #0x104ce2400
# [ChatTableViewCell nextResponder]
...
"<YYTableView: 0x105191800; baseClass = UITableView; frame = (0 0; 375 667); clipsToBounds = YES; gestureRecognizers = <NSArray: 0x17465ae20>; layer = <CALayer: 0x17462fce0>; contentOffset: {0, -64}; contentSize: {375, 206}>"
...
#"<BaseMsgContentViewController: 0x104d14c00>"
```
得到 `ChatTableViewCell` 和 `BaseMsgContentViewController`  
另外一种获取 `viewController` 方法:   

```
cy# UIApp.keyWindow.rootViewController
#"<MMTabBarController: 0x108076000>"
cy# var tabBarController = [UIApp keyWindow].rootViewController
#"<MMTabBarController: 0x108076000>"
cy# var detailViewController = tabBarController.selectedViewController.visibleViewController
#"<BaseMsgContentViewController: 0x1079a4200>"
```
####在Xcode中查看文件
打开Xcode 搜索 `@interface BaseMsgContentViewController` ，给自己发红包，在手机上点出红包的界面，然后通过 `cycript`  操作 

```
| <WCRedEnvelopesReceiveHomeView: 0x145798790; frame = (0 0; 375 667); clipsToBounds = YES; autoresize = W+H; layer = <CALayer: 0x145633cb0>>  
   ...
   ...
   |    |    | <UIButton: 0x1472231f0; frame = (107.5 233; 110 110); opaque = NO; layer = <CALayer: 0x1454a4200>>
   |    |    |    | <UIImageView: 0x1454a89b0; frame = (0 0; 110 110); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = <CALayer: 0x14726ccf0>>
   |    |    | <UIImageView: 0x1470e0cb0; frame = (107.5 233; 110 110); hidden = YES; opaque = NO; userInteractionEnabled = NO; layer = <CALayer: 0x1454bc710>>
   |    |    | <UIImageView: 0x1472234b0; frame = (150.5 397; 24 24); opaque = NO; userInteractionEnabled = NO; layer = <CALayer: 0x147030cc0>>`
cy# UIButton = #0x1472231f0
#"<UIButton: 0x1472231f0; frame = (107.5 233; 110 110); opaque = NO; layer = <CALayer: 0x1454a4200>>"
cy# [UIButton allTargets]
[NSSet setWithArray:@[#"<WCRedEnvelopesReceiveHomeView: 0x145798790; frame = (0 0; 375 667); clipsToBounds = YES; autoresize = W+H; layer = <CALayer: 0x145633cb0>>"]]]
cy# [UIButton allControlEvents]
64
cy# [UIButton actionsForTarget:#0x145798790 forControlEvent:64]
@["OnOpenRedEnvelopes"]
cy# [UIButton setHidden:YES]
cy# [UIButton setHidden:NO]

```
获取 `WCRedEnvelopesReceiveHomeView` 红包界面，以及 `OnOpenRedEnvelopes` 开红包的事件。
<center>![红包](/Users/tomorrow/Documents/博客/tupian.png)</center>  

```
void -[WCRedEnvelopesReceiveHomeView OnOpenRedEnvelopes](void * self, void * _cmd) 
{
    ...
    r19 = self;
    r0 = [r19];
    r0 = [r0 retain];
    r23 = [r0 intValue];
    ...
    r21 = [r0 intValue];
    ....
    loc_1029b0c88(zero_extend_64(0x2db5), [[NSString stringWithFormat:@"%u,%u,%u,%u,%u,%@", r3, stack[2048], stack[2049], stack[2050], stack[2051], stack[2052]] retain], zero_extend_64(0x0), zero_extend_64(0x0), stack[2048], stack[2049]);
    r0 = objc_loadWeakRetained(r19 + sign_extend_64(*(int32_t *)0x103b06ad4));
    [r0 WCRedEnvelopesReceiveHomeViewOpenRedEnvelopes];
    ...
}
```
#### 使用 dubgserver + lldb 动态调试
1. 在 `[WCRedEnvelopesReceiveHomeView OnOpenRedEnvelopes]` 方法处加断点
2. 触发断点，输入 `bt` 看到当前的调用栈
3. 根据公式 `函数在二进制中的偏移量＝内存地址 - 进程内存基地址`计算出偏移量
4. 在hooper中搜索这个地址，所有的栈都进行还原，得出调用方法  

#### `[WCRedEnvelopesReceiveHomeView WCRedEnvelopesReceiveHomeViewOpenRedEnvelopes]`方法分析
>
1. WCRedEnvelopesControlData 中的属性 `CMessageWrap *m_oSelectedMessageWrap`；  
2. CMessageWrap 中的属性 `WCPayInfoItem *m_oWCPayInfoItem`;
3. WCPayInfoItem 中的属性 `NSString *m_c2cNativeUrl`；  
4. [r27 m_oSelectedMessageWrap] ==> `NSString *m_c2cNativeUrl`

```
NSMutableDictionary *dict = [NSMutableDictionary dictionary];  
[dict setObject:@"1" forKey:@"msgType"];  
[dict setObject:[r20] forKey:@"sendId"];  
[dict setObject:[r20] forKey:@"channelId"];  
r20 = [[[MMServiceCenter defaultCenter] getService:[CContactMgr class]] getSelfContact];  
[dict setObject:[r20 getContactDisplayName] forKey:@"nickName"];  
[dict setObject:[r20 m_nsHeadImgUrl] forKey:@"headImg"];  
[dict setObject:[r27 m_oSelectedMessageWrap] forKey:@"nativeUrl"]
[dict setObject:[[r28 m_sontanct] m_nsUsrName] forKey:@"sessionUserName"];     
[dict setObject:[[r27 m_structDicRedEnvelopesBaseInfo] stringForKey:@"timingIdentifier"] forKey:@"timingIdentifier"];
[[[MMServiceCenter defaultCenter] getService:[WCPayLogicMgr class]] setRealnameReportScene:zero_extend_64(0x3eb)]
[[WCRedEnvelopesControlData.m_structDicRedEnvelopesBaseInfo stringForKey:@"timingIdentifier"] objectForKeyedSubscript:@"agree_duty"] 
[self checkHongbaoOpenLicense:r20 acceptCallback:r31 + 0x88 denyCallback:stack[2048]];
```
这些解析并不完整，使用 `logify` 查看打开红包方法调用顺序：

```
[<WCRedEnvelopesReceiveHomeView: 0x1504146e0> OnOpenRedEnvelopes]
[<WCRedEnvelopesReceiveControlLogic: 0x174699690> WCRedEnvelopesReceiveHomeViewOpenRedEnvelopes]
[<WCPayLogicMgr: 0x14ed84c50> setRealnameReportScene:1003]
[<WCPayLogicMgr: 0x14ed84c50> checkHongbaoOpenLicense:{
	    "agreed_flag" = 1;
	    "button_wording" = "";
	    "delay_expired_time" = 0;
	    "service_protocol_url" = "";
	    "service_protocol_wording" = "";
	    title = "";
	} acceptCallback:<__NSStackBlock__: 0x16fd35578> denyCallback:<__NSStackBlock__: 0x16fd35548>]
[<WCPayLogicMgr: 0x14ed84c50> setAlertViewScene:1]
[<WCPayLogicMgr: 0x14ed84c50> setIsFromViewLicense:0]
[<WCPayLogicMgr: 0x14ed84c50> setLicenseAcceptCallback:<__NSStackBlock__: 0x16fd35578>]
[<WCPayLogicMgr: 0x14ed84c50> setLicenseDenyCallback:<__NSStackBlock__: 0x16fd35548>]
[<WCPayLogicMgr: 0x14ed84c50> getAcceptRealnameLicense]
[<WCPayLogicMgr: 0x14ed84c50> getRealnameReportScene]
[<WCPayLogicMgr: 0x14ed84c50> setAcceptRealnameLicense:1]
[<WCPayLogicMgr: 0x14ed84c50> safeSaveLocalData]
[<WCPayLogicMgr: 0x14ed84c50> licenseAcceptCallback]
[<WCRedEnvelopesLogicMgr: 0x174e2ec80> OpenRedEnvelopesRequest:{
	    channelId = 1;
	    headImg = "xxxx";
	    msgType = 1;
	    nativeUrl = "xxxx";
	    nickName = "xxx";
	    sendId = xxxxxxx;
	    sessionUserName = "xxxxx";
	    timingIdentifier = xxxxxx;
	}]
```

`OpenRedEnvelopesRequest `就是网上流传的打开红包发起的网络请求！！
#### 获取红包通知
收到红包调用方法

```
[<CMessageMgr: 0x128d05590> CheckMessageStatus: Msg:]
[<CMessageMgr: 0x128d05590> InAppAttachDownloading: MsgWrap:]
[<CMessageMgr: 0x128d05590> MessageReturn:227 MessageInfo: Event:69]
[<CMessageMgr: 0x128d05590> AsyncOnPreAddMsg: MsgWrap:]
[<CMessageMgr: 0x128d05590> MessageReturn:45 MessageInfo:Event:69]
[<CMessageMgr: 0x128d05590> GetDownloadThumbStatus:]
[<CMessageMgr: 0x128d05590> AsyncOnAddMsg: MsgWrap:]
[<CMessageMgr: 0x128d05590> MessageReturn:344 MessageInfo: Event:69]
[<CMessageMgr: 0x128d05590> AsyncOnAddMsgListForSession: NotifyUsrName:{(
	    "wxid_akya9t5ui7xy12"
	)}]
[<CMessageMgr: 0x128d05590> MessageReturn:334 MessageInfo: Event:69]
[<CMessageMgr: 0x128d05590> AsyncOnPushMsg: ]
[<CMessageMgr: 0x128d05590> MainThreadNotifyToExt: ]
[<CMessageMgr: 0x128d05590> MainThreadNotifyToExt: ]
[<WCPayLogicMgr: 0x128d474e0> OnAddMsg:wxid_akya9t5ui7xy12 MsgWrap: ]
[<CMessageMgr: 0x128d05590> ModMsgWithoutNotify:wxid_akya9t5ui7xy12 MsgWrap: ]
[<BaseMsgContentViewController: 0x1292a9000> addMessageNode: layout:1 addMoreMsg:0]
[<CMessageMgr: 0x128d05590> MainThreadNotifyToExt:{
	   
	}]
[<CMessageMgr: 0x128d05590> GetUnReadCount:wxid_akya9t5ui7xy12]
[<CMessageMgr: 0x128d05590> CheckMessageStatus:wxid_akya9t5ui7xy12 Msg: ]
[<CMessageMgr: 0x128d05590> MainThreadNotifyToExt:{

	}]
```
`AsyncOnAddMsg: MsgWrap:` 获取红包方法 ~  
至此网上流传微信红包方法查找过程就完全找到了 (^_^)
#### TWEAK编写
通过 hook 上面的方法发现，只要收到红包通知进入微信就会调用`AsyncOnAddMsg: MsgWrap:`方法。

```
%hook CMessageMgr
- (void)AsyncOnAddMsg:(id)arg1 MsgWrap:(id)arg2
{
	%orig(arg1,arg2);
}
%end
```
